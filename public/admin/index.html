<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="noindex, nofollow" />
  <title>Administrace - DG Kralupy</title>

  <!-- Custom styles -->
  <style>
    /* Brand colors and custom styling */
    :root {
      --primary: #3b5f78;
      --primary-dark: #273946;
      --secondary: #44c2c4;
    }

    /* Custom admin interface styling */
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
        'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
        sans-serif;
    }

    /* Loading overlay - hidden once CMS loads */
    #loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #fff;
      font-size: 18px;
      color: var(--primary);
      z-index: 9999;
    }

    #loading-overlay.hidden {
      display: none;
    }
  </style>
</head>
<body>
  <!-- Loading overlay - hidden once CMS mounts -->
  <div id="loading-overlay">
    Naƒç√≠t√°n√≠ administrace...
  </div>

  <!-- Decap CMS -->
  <script src="https://unpkg.com/decap-cms@^3.0.0/dist/decap-cms.js"></script>
  
  <!-- Inline Custom Widgets Registration -->
  <script>
    /* eslint-disable no-undef, @typescript-eslint/no-this-alias */
    /* global CMS, h, createClass */
    (function() {
      'use strict';

      console.log('='.repeat(60));
      console.log('üöÄ WIDGET REGISTRATION SCRIPT STARTED');
      console.log('='.repeat(60));

      // Check if required globals are available
      console.log('Checking required globals...');
      console.log('- window.CMS:', typeof window.CMS, window.CMS);
      console.log('- createClass:', typeof createClass);
      console.log('- h:', typeof h);

      if (!window.CMS) {
        console.error('‚ùå CRITICAL: CMS object not found! Decap CMS may not be loaded yet.');
        return;
      }

      if (typeof createClass === 'undefined') {
        console.error('‚ùå CRITICAL: createClass function not found!');
        return;
      }

      if (typeof h === 'undefined') {
        console.error('‚ùå CRITICAL: h function not found!');
        return;
      }

      console.log('‚úÖ All required globals are available');

        // ==========================================
        // AUTHOR WIDGET
        // ==========================================
        console.log('üìù Defining Author widget...');
        var AuthorControl = createClass({
          // Configuration constants
          RETRY_CONFIG: {
            MAX_ATTEMPTS: 10,
            INITIAL_DELAY_MS: 200,
            BACKOFF_MULTIPLIER: 1.5,
            FETCH_TIMEOUT_MS: 5000
          },

          getInitialState: function() {
            return {
              author: 'Redakce',
              githubUser: null,
              error: null,
              isLoadingAuthor: false,
              retryTimeouts: []
            };
          },

          componentDidMount: function() {
            this.determineAuthor();
          },

          componentWillUnmount: function() {
            // Critical: cleanup pending timeouts to prevent memory leaks
            if (this.state.retryTimeouts && this.state.retryTimeouts.length > 0) {
              console.log('[Author Widget] Cleaning up ' + this.state.retryTimeouts.length + ' pending timeouts');
              this.state.retryTimeouts.forEach(function(timeoutId) {
                clearTimeout(timeoutId);
              });
            }
          },

          // Helper: Fetch with timeout
          fetchWithTimeout: function(url, timeout) {
            return Promise.race([
              fetch(url),
              new Promise(function(_, reject) {
                setTimeout(function() {
                  reject(new Error('Request timeout'));
                }, timeout);
              })
            ]);
          },

          // Helper: Determine base path for authors.json
          getBasePath: function() {
            // Option 1: Try to read from field config (configurable in config.yml)
            var configuredPath = this.props.field && this.props.field.get('base_path');
            if (configuredPath) {
              console.log('[Author Widget] Using configured base path:', configuredPath);
              return configuredPath;
            }

            // Option 2: Auto-detect based on hostname
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
              console.log('[Author Widget] Detected localhost, using empty base path');
              return '';
            }

            // Option 3: Extract from URL pathname
            var pathParts = window.location.pathname.split('/').filter(function(p) { return p; });
            var adminIndex = pathParts.indexOf('admin');

            if (adminIndex > 0) {
              // Extract everything before 'admin' as base path
              var basePath = '/' + pathParts.slice(0, adminIndex).join('/');
              console.log('[Author Widget] Extracted base path from URL:', basePath);
              return basePath;
            } else if (pathParts.length > 0 && pathParts[0] !== 'admin') {
              // First segment is base path (not 'admin')
              var basePath = '/' + pathParts[0];
              console.log('[Author Widget] Using first path segment as base:', basePath);
              return basePath;
            }

            console.log('[Author Widget] No base path detected, using root');
            return '';
          },

          determineAuthor: function() {
            var self = this;

            // Prevent concurrent execution (race condition protection)
            if (this.state.isLoadingAuthor) {
              console.log('[Author Widget] Author determination already in progress, skipping');
              return;
            }

            this.setState({ isLoadingAuthor: true });

            var maxRetries = this.RETRY_CONFIG.MAX_ATTEMPTS;
            var initialDelay = this.RETRY_CONFIG.INITIAL_DELAY_MS;
            var backoffMultiplier = this.RETRY_CONFIG.BACKOFF_MULTIPLIER;

            function attemptGetBackend(retryCount) {
              var backend = window.CMS && window.CMS.getBackend && window.CMS.getBackend();

              // Check if backend is ready
              if (!backend || !backend.currentUser) {
                if (retryCount < maxRetries) {
                  var delay = initialDelay * Math.pow(backoffMultiplier, retryCount);
                  console.log('[Author Widget] Backend not ready, retrying in ' + Math.round(delay) + 'ms... (' + (retryCount + 1) + '/' + maxRetries + ')');

                  var timeoutId = setTimeout(function() {
                    attemptGetBackend(retryCount + 1);
                  }, delay);

                  // Track timeout for cleanup
                  self.setState(function(prevState) {
                    return {
                      retryTimeouts: prevState.retryTimeouts.concat([timeoutId])
                    };
                  });
                  return;
                } else {
                  console.error('[Author Widget] Backend not available after ' + maxRetries + ' retries');
                  self.setState({
                    author: 'Redakce',
                    error: 'GitHub autentizace nedostupn√°. Zkontrolujte p≈ôipojen√≠.',
                    isLoadingAuthor: false
                  });
                  self.props.onChange('Redakce');
                  return;
                }
              }

              // Backend is ready, proceed with author determination
              console.log('[Author Widget] Backend ready, fetching current user');

              backend.currentUser().then(function(user) {
                var githubUsername = user && (user.login || user.name);

                if (!githubUsername) {
                  throw new Error('GitHub u≈æivatel nenalezen');
                }

                console.log('[Author Widget] GitHub user:', githubUsername);
                self.setState({ githubUser: githubUsername });

                // Determine base path dynamically
                var basePath = self.getBasePath();
                var authorsPath = basePath + '/content/authors/authors.json';
                console.log('[Author Widget] Loading authors from:', authorsPath);

                // Fetch author mappings with timeout
                return self.fetchWithTimeout(authorsPath, self.RETRY_CONFIG.FETCH_TIMEOUT_MS)
                  .then(function(response) {
                    if (!response.ok) {
                      throw new Error('Soubor authors.json nenalezen na cestƒõ: ' + authorsPath);
                    }
                    return response.json();
                  })
                  .then(function(data) {
                    // Support both old object format and new array format
                    var mappings = data.mappings || [];
                    var mapping = null;

                    // Try array format first (new format)
                    if (Array.isArray(mappings)) {
                      mapping = mappings.find(function(m) {
                        return m.github === githubUsername;
                      });
                    }
                    // Fallback to object format (old format)
                    else if (data.mapping && typeof data.mapping === 'object') {
                      var displayName = data.mapping[githubUsername];
                      if (displayName) {
                        mapping = { displayName: displayName };
                      }
                    }

                    var authorName = mapping ? mapping.displayName : (data.defaultAuthor || 'Redakce');

                    console.log('[Author Widget] Author mapping:', githubUsername, '‚Üí', authorName);

                    self.setState({
                      author: authorName,
                      error: null,
                      isLoadingAuthor: false
                    });
                    self.props.onChange(authorName);
                  });
              }).catch(function(error) {
                console.error('[Author Widget] Error loading author:', error);
                self.setState({
                  author: 'Redakce',
                  error: error.message,
                  isLoadingAuthor: false
                });
                self.props.onChange('Redakce');
              });
            }

            // Start the retry process
            attemptGetBackend(0);
          },

          render: function() {
            var self = this;
            return h('div', {
              className: this.props.classNameWrapper,
              style: { padding: '10px', borderRadius: '4px', border: '1px solid #ddd', backgroundColor: '#fafafa' }
            },
              h('label', {
                htmlFor: this.props.forID,
                style: { display: 'block', marginBottom: '5px', fontWeight: 'bold', fontSize: '14px' }
              }, 'Autor'),

              h('input', {
                type: 'text',
                id: this.props.forID,
                value: this.state.author,
                readOnly: true,
                style: {
                  width: '100%',
                  padding: '8px',
                  backgroundColor: '#f5f5f5',
                  border: '1px solid #ccc',
                  borderRadius: '3px',
                  fontSize: '14px'
                }
              }),

              // Loading indicator during retry
              this.state.isLoadingAuthor && h('p', {
                style: {
                  marginTop: '8px',
                  marginBottom: '4px',
                  fontSize: '13px',
                  color: '#666',
                  fontStyle: 'italic'
                }
              }, '‚è≥ Naƒç√≠t√°n√≠ autora z GitHub √∫ƒçtu...'),

              // Status message or error
              h('p', {
                style: {
                  marginTop: '8px',
                  marginBottom: '0',
                  fontSize: '12px',
                  color: this.state.error ? '#c44d58' : '#888'
                }
              },
                this.state.error
                  ? '‚ö†Ô∏è ' + this.state.error
                  : (this.state.githubUser
                      ? 'GitHub √∫ƒçet: ' + this.state.githubUser
                      : 'Autor je nastaven automaticky na z√°kladƒõ va≈°eho GitHub √∫ƒçtu')
              )
            );
          }
        });

        console.log('‚úÖ Author control component defined');

        var AuthorPreview = createClass({
          render: function() {
            return h('div', {},
              h('strong', {}, 'Autor: '),
              this.props.value || 'Redakce'
            );
          }
        });
        console.log('‚úÖ Author preview component defined');

        // ==========================================
        // ENHANCED IMAGE WIDGET
        // ==========================================
        console.log('üñºÔ∏è  Defining Enhanced Image widget...');
        var MAX_ALT_LENGTH = 125;
        var MAX_FILE_SIZE = 5 * 1024 * 1024; // 5 MB
        var ALLOWED_TYPES = ['image/jpeg', 'image/png', 'image/webp'];

        var EnhancedImageControl = createClass({
          getInitialState: function() {
            var value = this.props.value || {};
            return {
              src: value.src || null,
              alt: value.alt || '',
              focusPoint: value.focusPoint || { x: 50, y: 50 },
              crops: value.crops || {},
              error: null,
              isDragging: false
            };
          },

          validateFile: function(file) {
            if (!ALLOWED_TYPES.includes(file.type)) {
              return 'Podporovan√© form√°ty: JPG, PNG, WebP';
            }
            if (file.size > MAX_FILE_SIZE) {
              return 'Maxim√°ln√≠ velikost souboru je 5 MB';
            }
            return null;
          },

          handleFileSelect: function(e) {
            var self = this;
            var file = e.target.files[0];
            if (!file) return;

            var validationError = this.validateFile(file);
            if (validationError) {
              this.setState({ error: validationError });
              return;
            }

            // Use CMS media library for upload
            if (this.props.onOpenMediaLibrary) {
              this.props.onOpenMediaLibrary({
                controlMedia: this.props.mediaPaths && this.props.mediaPaths.get(this.props.field.get('name')),
                forImage: true
              }).then(function(mediaFile) {
                self.setState({
                  src: mediaFile.path,
                  error: null
                }, function() {
                  self.emitChange();
                });
              }).catch(function(error) {
                console.error('Image upload error:', error);
                self.setState({ error: 'Nahr√°v√°n√≠ se nezda≈ôilo: ' + error.message });
              });
            }
          },

          handleAltChange: function(e) {
            var alt = e.target.value.slice(0, MAX_ALT_LENGTH);
            var self = this;
            this.setState({ alt: alt }, function() {
              self.emitChange();
            });
          },

          handleFocusPointChange: function(e) {
            var rect = e.currentTarget.getBoundingClientRect();
            var x = Math.round(((e.clientX - rect.left) / rect.width) * 100);
            var y = Math.round(((e.clientY - rect.top) / rect.height) * 100);
            var self = this;

            this.setState({
              focusPoint: {
                x: Math.max(0, Math.min(100, x)),
                y: Math.max(0, Math.min(100, y))
              }
            }, function() {
              self.emitChange();
            });
          },

          handleRemove: function() {
            this.setState({
              src: null,
              alt: '',
              focusPoint: { x: 50, y: 50 },
              crops: {}
            });
            this.props.onChange(null);
          },

          emitChange: function() {
            var src = this.state.src;
            var alt = this.state.alt;
            var focusPoint = this.state.focusPoint;
            var crops = this.state.crops;

            if (!src) {
              this.props.onChange(null);
              return;
            }

            this.props.onChange({
              src: src,
              alt: alt,
              focusPoint: focusPoint,
              crops: crops
            });
          },

          handleDropzoneClick: function() {
            if (this.fileInputRef) {
              this.fileInputRef.click();
            }
          },

          render: function() {
            var self = this;
            var src = this.state.src;
            var alt = this.state.alt;
            var focusPoint = this.state.focusPoint;
            var error = this.state.error;
            var isDragging = this.state.isDragging;

            var containerStyle = {
              border: '1px solid #ddd',
              borderRadius: '4px',
              padding: '16px',
              marginBottom: '16px'
            };

            var dropzoneStyle = {
              border: '2px dashed ' + (isDragging ? '#3b5f78' : '#ccc'),
              borderRadius: '8px',
              padding: '40px',
              textAlign: 'center',
              cursor: 'pointer',
              backgroundColor: isDragging ? '#f0f7ff' : 'transparent',
              transition: 'all 0.2s'
            };

            var errorStyle = {
              padding: '12px',
              backgroundColor: '#fee',
              border: '1px solid #fcc',
              borderRadius: '4px',
              color: '#c00',
              marginBottom: '12px'
            };

            return h('div', { className: 'enhanced-image-widget', style: containerStyle },
              error && h('div', { style: errorStyle }, error),
              
              !src && h('div', {
                style: dropzoneStyle,
                onClick: this.handleDropzoneClick
              },
                h('p', {}, 'üìÅ Kliknƒõte nebo p≈ôet√°hnƒõte obr√°zek'),
                h('p', { style: { fontSize: '12px', color: '#666', marginTop: '4px' } }, 
                  'JPG, PNG, WebP ‚Ä¢ Max 5 MB'),
                h('input', {
                  ref: function(ref) { self.fileInputRef = ref; },
                  type: 'file',
                  accept: 'image/jpeg,image/png,image/webp',
                  style: { display: 'none' },
                  onChange: this.handleFileSelect
                })
              ),
              
              src && h('div', { style: { marginTop: '16px' } },
                h('div', {
                  style: {
                    position: 'relative',
                    cursor: 'crosshair',
                    marginBottom: '16px'
                  },
                  onClick: this.handleFocusPointChange
                },
                  h('img', {
                    src: src,
                    alt: alt,
                    style: {
                      maxWidth: '100%',
                      display: 'block',
                      borderRadius: '4px'
                    }
                  }),
                  h('div', {
                    style: {
                      position: 'absolute',
                      width: '20px',
                      height: '20px',
                      marginLeft: '-10px',
                      marginTop: '-10px',
                      borderRadius: '50%',
                      border: '3px solid #ff6b6b',
                      backgroundColor: 'rgba(255, 107, 107, 0.3)',
                      pointerEvents: 'none',
                      left: focusPoint.x + '%',
                      top: focusPoint.y + '%'
                    }
                  })
                ),
                
                h('div', { style: { marginBottom: '12px' } },
                  h('label', {
                    style: {
                      display: 'block',
                      marginBottom: '4px',
                      fontWeight: 500,
                      fontSize: '14px'
                    }
                  }, 'Alternativn√≠ text (povinn√Ω)'),
                  h('input', {
                    type: 'text',
                    value: alt,
                    maxLength: MAX_ALT_LENGTH,
                    placeholder: 'Popis obr√°zku pro nevidom√© u≈æivatele',
                    style: {
                      width: '100%',
                      padding: '8px',
                      border: '1px solid #ddd',
                      borderRadius: '4px',
                      fontSize: '14px'
                    },
                    onChange: this.handleAltChange
                  }),
                  h('span', {
                    style: {
                      fontSize: '12px',
                      color: '#666',
                      marginTop: '4px',
                      display: 'block'
                    }
                  }, alt.length + '/' + MAX_ALT_LENGTH + ' znak≈Ø')
                ),
                
                h('div', {
                  style: {
                    padding: '8px',
                    backgroundColor: '#f5f5f5',
                    borderRadius: '4px',
                    fontSize: '13px',
                    marginBottom: '12px'
                  }
                },
                  h('strong', {}, 'Ohnisko: '),
                  focusPoint.x + '%, ' + focusPoint.y + '% ‚Ä¢ Kliknƒõte na obr√°zek pro zmƒõnu'
                ),
                
                h('button', {
                  type: 'button',
                  style: {
                    padding: '8px 16px',
                    backgroundColor: '#f44',
                    color: 'white',
                    border: 'none',
                    borderRadius: '4px',
                    cursor: 'pointer'
                  },
                  onClick: this.handleRemove
                }, 'üóëÔ∏è Odstranit obr√°zek')
              )
            );
          }
        });
        console.log('‚úÖ Enhanced Image control component defined');

        var EnhancedImagePreview = createClass({
          render: function() {
            var value = this.props.value || {};

            if (!value.src) {
              return h('div', {}, '≈Ω√°dn√Ω obr√°zek');
            }

            return h('div', {},
              h('img', {
                src: value.src,
                alt: value.alt,
                style: {
                  maxWidth: '300px',
                  display: 'block',
                  marginBottom: '8px'
                }
              }),
              value.alt && h('p', {}, value.alt)
            );
          }
        });
        console.log('‚úÖ Enhanced Image preview component defined');

      // ==========================================
      // REGISTER WIDGETS
      // ==========================================
      console.log('');
      console.log('üìã Starting widget registration...');
      console.log('- CMS.registerWidget type:', typeof CMS.registerWidget);

      try {
        console.log('Registering author widget...');
        console.log('- Control:', typeof AuthorControl);
        console.log('- Preview:', typeof AuthorPreview);
        CMS.registerWidget('author', AuthorControl, AuthorPreview);
        console.log('‚úÖ Author widget registered successfully');

        console.log('Registering enhanced-image widget...');
        console.log('- Control:', typeof EnhancedImageControl);
        console.log('- Preview:', typeof EnhancedImagePreview);
        CMS.registerWidget('enhanced-image', EnhancedImageControl, EnhancedImagePreview);
        console.log('‚úÖ Enhanced-image widget registered successfully');

        console.log('');
        console.log('='.repeat(60));
        console.log('üéâ ALL CUSTOM WIDGETS REGISTERED SUCCESSFULLY');
        console.log('='.repeat(60));
      } catch (error) {
        console.error('');
        console.error('='.repeat(60));
        console.error('‚ùå WIDGET REGISTRATION FAILED');
        console.error('='.repeat(60));
        console.error('Error:', error);
        console.error('Error message:', error.message);
        console.error('Error stack:', error.stack);
        
        // Display error to user
        var errorDiv = document.createElement('div');
        errorDiv.style.cssText = '\
          position: fixed;\
          top: 20px;\
          left: 50%;\
          transform: translateX(-50%);\
          background: #fee;\
          border: 2px solid #c00;\
          color: #c00;\
          padding: 16px 24px;\
          border-radius: 8px;\
          z-index: 10000;\
          font-family: sans-serif;\
          max-width: 500px;\
          text-align: center;\
        ';
        errorDiv.textContent = 'Chyba p≈ôi registraci widget≈Ø: ' + error.message;
        document.body.appendChild(errorDiv);
      }

      // ==========================================
      // VERIFY REGISTRATION
      // ==========================================
      console.log('');
      console.log('üîç Verifying widget registration...');
      if (window.CMS && window.CMS.getWidget) {
        try {
          var authorWidget = CMS.getWidget('author');
          var imageWidget = CMS.getWidget('enhanced-image');
          console.log('- author widget:', authorWidget ? '‚úÖ Found' : '‚ùå Not found');
          console.log('- enhanced-image widget:', imageWidget ? '‚úÖ Found' : '‚ùå Not found');
        } catch (e) {
          console.log('‚ö†Ô∏è Could not verify widgets using CMS.getWidget():', e.message);
        }
      } else {
        console.log('‚ö†Ô∏è CMS.getWidget() not available');
      }

      // ==========================================
      // HIDE LOADING OVERLAY WHEN CMS READY
      // ==========================================
      CMS.registerEventListener({
        name: 'postPublish',
        handler: function() {
          var loadingOverlay = document.getElementById('loading-overlay');
          if (loadingOverlay) {
            loadingOverlay.classList.add('hidden');
          }
        }
      });

      // Hide loading overlay after a short delay to ensure CMS has mounted
      setTimeout(function() {
        var loadingOverlay = document.getElementById('loading-overlay');
        if (loadingOverlay) {
          loadingOverlay.classList.add('hidden');
        }
      }, 1000);

    })();
  </script>
</body>
</html>