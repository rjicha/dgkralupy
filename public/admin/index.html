<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="noindex, nofollow" />
  <title>Administrace - DG Kralupy</title>

  <!-- Custom styles -->
  <style>
    /* Brand colors and custom styling */
    :root {
      --primary: #3b5f78;
      --primary-dark: #273946;
      --secondary: #44c2c4;
    }

    /* Custom admin interface styling */
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
        'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
        sans-serif;
    }

    /* Loading overlay - hidden once CMS loads */
    #loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #fff;
      font-size: 18px;
      color: var(--primary);
      z-index: 9999;
    }

    #loading-overlay.hidden {
      display: none;
    }
  </style>
</head>
<body>
  <!-- Loading overlay - hidden once CMS mounts -->
  <div id="loading-overlay">
    Naƒç√≠t√°n√≠ administrace...
  </div>

  <!-- Decap CMS -->
  <script src="https://unpkg.com/decap-cms@^3.0.0/dist/decap-cms.js"></script>

  <!-- Cloudinary Upload Widget -->
  <script src="https://upload-widget.cloudinary.com/global/all.js" type="text/javascript"></script>

  <!-- Cloudinary Configuration -->
  <script src="./cloudinary-config.js"></script>

  <!-- Inline Custom Widgets Registration -->
  <script>
    /* eslint-disable no-undef, @typescript-eslint/no-this-alias */
    /* global CMS, h, createClass */
    (function() {
      'use strict';

      console.log('='.repeat(60));
      console.log('üöÄ WIDGET REGISTRATION SCRIPT STARTED');
      console.log('='.repeat(60));

      // Check if required globals are available
      console.log('Checking required globals...');
      console.log('- window.CMS:', typeof window.CMS, window.CMS);
      console.log('- createClass:', typeof createClass);
      console.log('- h:', typeof h);

      if (!window.CMS) {
        console.error('‚ùå CRITICAL: CMS object not found! Decap CMS may not be loaded yet.');
        return;
      }

      if (typeof createClass === 'undefined') {
        console.error('‚ùå CRITICAL: createClass function not found!');
        return;
      }

      if (typeof h === 'undefined') {
        console.error('‚ùå CRITICAL: h function not found!');
        return;
      }

      console.log('‚úÖ All required globals are available');

        // ==========================================
        // AUTHOR WIDGET (localStorage-based)
        // ==========================================
        // Uses undocumented localStorage access to read current user
        // Decap CMS stores user data in: window.localStorage.getItem('decap-cms-user')
        console.log('üìù Defining Author widget...');

        var AuthorControl = createClass({
          getInitialState: function() {
            return {
              author: this.props.value || 'Redakce',
              isAutoPopulated: false
            };
          },

          componentDidMount: function() {
            var self = this;

            // Don't override if user already set a value
            if (this.props.value) {
              console.log('[Author Widget] Using existing value:', this.props.value);
              return;
            }

            try {
              // Read user from localStorage (where Decap CMS stores it)
              var storedUser = window.localStorage.getItem('decap-cms-user');

              if (!storedUser) {
                console.log('[Author Widget] No stored user found, using default');
                this.setState({ author: 'Redakce' });
                this.props.onChange('Redakce');
                return;
              }

              var userData = JSON.parse(storedUser);
              console.log('[Author Widget] Found stored user:', userData);

              // Extract username (GitHub: login, GitLab/Bitbucket: username)
              var username = userData.login || userData.username || userData.name;

              if (!username) {
                console.log('[Author Widget] No username in stored data, using default');
                this.setState({ author: 'Redakce' });
                this.props.onChange('Redakce');
                return;
              }

              console.log('[Author Widget] GitHub username:', username);

              // Determine base path - handle both dev and production
              var basePath = '';
              var pathParts = window.location.pathname.split('/').filter(function(p) { return p; });

              // In dev: /dgkralupy/admin/index.html -> base is /dgkralupy
              // In prod: /dgkralupy/admin/ -> base is /dgkralupy
              if (pathParts.length > 0 && pathParts[0] !== 'admin') {
                basePath = '/' + pathParts[0];
              }

              // The file is in the public folder at build time, served at root
              var authorsPath = basePath + '/authors.json';
              console.log('[Author Widget] Loading authors from:', authorsPath);

              // Fetch and map username to display name
              fetch(authorsPath)
                .then(function(response) {
                  if (!response.ok) {
                    throw new Error('authors.json not found');
                  }
                  return response.json();
                })
                .then(function(data) {
                  var mapping = data.mappings.find(function(m) {
                    return m.github === username || m.username === username;
                  });
                  var authorName = mapping ? mapping.displayName : (data.defaultAuthor || 'Redakce');

                  console.log('[Author Widget] Mapped:', username, '‚Üí', authorName);
                  self.setState({
                    author: authorName,
                    isAutoPopulated: true
                  });
                  self.props.onChange(authorName);
                })
                .catch(function(error) {
                  console.log('[Author Widget] Error loading authors.json:', error.message);
                  // Fallback: use GitHub username as-is
                  self.setState({
                    author: username,
                    isAutoPopulated: true
                  });
                  self.props.onChange(username);
                });

            } catch (error) {
              console.log('[Author Widget] Error:', error.message, '- using default');
              this.setState({ author: 'Redakce' });
              this.props.onChange('Redakce');
            }
          },

          render: function() {
            return h('div', {
              className: this.props.classNameWrapper,
              style: { padding: '10px', borderRadius: '4px', border: '1px solid #ddd', backgroundColor: '#fafafa' }
            },
              h('label', {
                htmlFor: this.props.forID,
                style: { display: 'block', marginBottom: '5px', fontWeight: 'bold', fontSize: '14px' }
              }, 'Autor'),

              h('input', {
                type: 'text',
                id: this.props.forID,
                value: this.state.author,
                readOnly: true,
                style: {
                  width: '100%',
                  padding: '8px',
                  backgroundColor: '#f5f5f5',
                  border: '1px solid #ccc',
                  borderRadius: '3px',
                  fontSize: '14px'
                }
              }),

              h('p', {
                style: {
                  marginTop: '8px',
                  marginBottom: '0',
                  fontSize: '12px',
                  color: '#888'
                }
              }, this.state.isAutoPopulated
                  ? 'Autor nastaven automaticky z GitHub √∫ƒçtu'
                  : 'Autor je nastaven automaticky p≈ôi vytvo≈ôen√≠ ƒçl√°nku')
            );
          }
        });

        console.log('‚úÖ Author control component defined');

        var AuthorPreview = createClass({
          render: function() {
            return h('div', {},
              h('strong', {}, 'Autor: '),
              this.props.value || 'Redakce'
            );
          }
        });
        console.log('‚úÖ Author preview component defined');

        // ==========================================
        // ENHANCED IMAGE WIDGET
        // ==========================================
        console.log('üñºÔ∏è  Defining Enhanced Image widget...');
        var MAX_ALT_LENGTH = 125;
        var MAX_FILE_SIZE = 5 * 1024 * 1024; // 5 MB
        var ALLOWED_TYPES = ['image/jpeg', 'image/png', 'image/webp'];

        var EnhancedImageControl = createClass({
          getInitialState: function() {
            console.log('='.repeat(60));
            console.log('[Enhanced Image] getInitialState called');
            console.log('[Enhanced Image] this.props.value:', this.props.value);
            console.log('[Enhanced Image] Value type:', typeof this.props.value);
            console.log('='.repeat(60));

            var value = this.props.value;

            // Base state
            var state = {
              error: null,
              isDragging: false,
              previewUrl: null,
              src: null,
              alt: '',
              focusPoint: { x: 50, y: 50 },
              crops: {},
              imageRect: null  // Store image bounding rect for correct indicator positioning
            };

            // Handle different value types
            if (!value) {
              console.log('[Enhanced Image] No initial value');
              return state;
            }

            if (typeof value === 'string') {
              // NEW FORMAT: Just public_id string (e.g., "dgkralupy/image.jpg")
              // OR legacy full URL
              console.log('[Enhanced Image] Initializing with string:', value);
              state.src = value;

              // Build Cloudinary URL for preview if it's a public_id (not a full URL)
              if (!value.startsWith('http')) {
                state.previewUrl = window.CLOUDINARY_CONFIG.buildUrl(value);
                console.log('[Enhanced Image] Built preview URL for initial state:', state.previewUrl);
              } else {
                state.previewUrl = value;
                console.log('[Enhanced Image] Using full URL as preview:', value);
              }

              return state;
            }

            if (typeof value === 'object') {
              // Handle Immutable.js Map (Decap CMS uses Immutable.js)
              console.log('[Enhanced Image] Initializing with object format:', value);

              // Check if it's an Immutable Map
              var srcValue;
              var altValue;
              var focusPointValue;
              var cropsValue;

              if (value.get) {
                // Immutable Map - use .get() method
                console.log('[Enhanced Image] Detected Immutable Map, using .get()');
                srcValue = value.get('src') || value.get('url') || null;
                altValue = value.get('alt') || '';
                focusPointValue = value.get('focusPoint');
                cropsValue = value.get('crops');

                // Convert Immutable focusPoint to plain object if needed
                if (focusPointValue && focusPointValue.toJS) {
                  focusPointValue = focusPointValue.toJS();
                }
                if (cropsValue && cropsValue.toJS) {
                  cropsValue = cropsValue.toJS();
                }
              } else {
                // Plain JavaScript object
                console.log('[Enhanced Image] Plain object, using dot notation');
                srcValue = value.src || value.url || null;
                altValue = value.alt || '';
                focusPointValue = value.focusPoint;
                cropsValue = value.crops;
              }

              state.src = srcValue;
              state.alt = altValue;
              state.focusPoint = focusPointValue || { x: 50, y: 50 };
              state.crops = cropsValue || {};

              // Build preview URL from src
              if (srcValue && !srcValue.startsWith('http')) {
                state.previewUrl = window.CLOUDINARY_CONFIG.buildUrl(srcValue);
                console.log('[Enhanced Image] Built preview URL from object public_id:', state.previewUrl);
              } else if (srcValue) {
                state.previewUrl = srcValue;
                console.log('[Enhanced Image] Using object full URL as preview:', state.previewUrl);
              }

              return state;
            }

            // Fallback for unexpected types
            console.warn('[Enhanced Image] Unexpected value type:', typeof value, value);
            return state;
          },

          componentDidUpdate: function(prevProps) {
            console.log('[Enhanced Image] componentDidUpdate called');
            console.log('[Enhanced Image] prevProps.value:', prevProps.value);
            console.log('[Enhanced Image] this.props.value:', this.props.value);

            // Only update if value actually changed
            if (prevProps.value !== this.props.value && this.props.value) {
              var value = this.props.value;
              console.log('[Enhanced Image] Value changed! New value:', value);
              console.log('[Enhanced Image] Value type:', typeof value);

              var newState = {};

              if (typeof value === 'string') {
                // NEW FORMAT: public_id string
                console.log('[Enhanced Image] Received public_id string:', value);

                // Build Cloudinary URL for preview if it's a public_id (not a full URL)
                if (!value.startsWith('http')) {
                  // It's a public_id, build Cloudinary URL
                  newState.previewUrl = window.CLOUDINARY_CONFIG.buildUrl(value);
                  console.log('[Enhanced Image] Built preview URL:', newState.previewUrl);
                } else {
                  newState.previewUrl = value;
                  console.log('[Enhanced Image] Using full URL as preview:', value);
                }

                newState.src = value;
                newState.error = null;

              } else if (typeof value === 'object' && value !== null) {
                // Handle Immutable.js Map or plain object
                console.log('[Enhanced Image] Received object format:', value);

                var srcValue;
                var altValue;
                var focusPointValue;

                if (value.get) {
                  // Immutable Map - use .get() method
                  console.log('[Enhanced Image] Detected Immutable Map in componentDidUpdate');
                  srcValue = value.get('src') || value.get('url') || null;
                  altValue = value.get('alt') || '';
                  focusPointValue = value.get('focusPoint');

                  // Convert Immutable focusPoint to plain object if needed
                  if (focusPointValue && focusPointValue.toJS) {
                    focusPointValue = focusPointValue.toJS();
                  }
                } else {
                  // Plain JavaScript object
                  console.log('[Enhanced Image] Plain object in componentDidUpdate');
                  srcValue = value.src || value.url || null;
                  altValue = value.alt || '';
                  focusPointValue = value.focusPoint;
                }

                newState.src = srcValue;

                // Build preview URL
                if (srcValue && !srcValue.startsWith('http')) {
                  // Build Cloudinary URL for public_id
                  newState.previewUrl = window.CLOUDINARY_CONFIG.buildUrl(srcValue);
                  console.log('[Enhanced Image] Built preview URL from public_id:', newState.previewUrl);
                } else if (srcValue) {
                  newState.previewUrl = srcValue;
                  console.log('[Enhanced Image] Using full URL as preview:', srcValue);
                }

                // Only update alt/focusPoint if the IMAGE changed (src changed)
                // This preserves user edits while they're editing the SAME image
                if (this.state.src !== srcValue) {
                  console.log('[Enhanced Image] Image changed, loading new alt and focusPoint');
                  newState.alt = altValue;
                  newState.focusPoint = focusPointValue || { x: 50, y: 50 };
                } else {
                  console.log('[Enhanced Image] Same image, preserving user edits to alt/focusPoint');
                }

                newState.error = null;

              } else {
                console.log('[Enhanced Image] Invalid value type, ignoring');
                return;
              }

              console.log('[Enhanced Image] Setting new state:', newState);
              // DO NOT call emitChange() here to avoid infinite loop
              this.setState(newState, function() {
                console.log('[Enhanced Image] State updated successfully');
              });
            }
          },

          validateFile: function(file) {
            if (!ALLOWED_TYPES.includes(file.type)) {
              return 'Podporovan√© form√°ty: JPG, PNG, WebP';
            }
            if (file.size > MAX_FILE_SIZE) {
              return 'Maxim√°ln√≠ velikost souboru je 5 MB';
            }
            return null;
          },

          handleFileSelect: function(e) {
            var self = this;
            var file = e.target.files[0];
            if (!file) return;

            console.log('File selected:', file.name, file.type, file.size);
            console.log('Available props:', Object.keys(this.props));

            var validationError = this.validateFile(file);
            if (validationError) {
              console.error('Validation error:', validationError);
              this.setState({ error: validationError });
              return;
            }

            // Add the asset to Decap CMS's media store
            if (this.props.onAddAsset) {
              console.log('Using onAddAsset to upload file...');
              try {
                // onAddAsset returns a Redux action {type: 'ADD_ASSET', payload: File}
                var action = this.props.onAddAsset(file);
                console.log('onAddAsset returned:', action);

                // Extract the file from the action payload
                var uploadedFile = action.payload;

                // Construct the image path based on public_folder setting
                // Files go to media_folder (public/images) and are served from public_folder (/images)
                var imagePath = '/images/' + uploadedFile.name;

                // Create a blob URL for preview (since file isn't on server yet)
                var blobUrl = URL.createObjectURL(uploadedFile);

                console.log('Constructed image path:', imagePath);
                console.log('Created blob URL for preview:', blobUrl);

                // Store the final path for saving, but use blob URL for preview
                self.setState({
                  src: imagePath,  // This will be saved in frontmatter
                  previewUrl: blobUrl,  // This will be used for display
                  error: null
                }, function() {
                  console.log('State updated successfully');
                  self.emitChange();
                });
              } catch (error) {
                console.error('Error in onAddAsset:', error);
                self.setState({ error: 'Chyba p≈ôi nahr√°v√°n√≠: ' + error.message });
              }
            } else {
              console.error('onAddAsset not available in props');
              self.setState({ error: 'Nahr√°v√°n√≠ soubor≈Ø nen√≠ dostupn√©' });
            }
          },

          handleAltChange: function(e) {
            var alt = e.target.value.slice(0, MAX_ALT_LENGTH);
            var self = this;
            this.setState({ alt: alt }, function() {
              self.emitChange();
            });
          },

          handleFocusPointChange: function(e) {
            // Get the actual element that was clicked (should be the img)
            var target = e.target;

            // Safety check: Only process clicks on the image element
            // (Ignore clicks on empty space in container)
            // Use toUpperCase() for case-insensitive comparison (browser compatibility)
            if (target.tagName.toUpperCase() !== 'IMG') {
              console.log('[Enhanced Image] Click outside image area, ignoring');
              return;
            }

            // Use the IMAGE element's bounding box, not the container's
            // This ensures correct percentage calculation even when image doesn't fill container
            var rect = target.getBoundingClientRect();
            var containerRect = e.currentTarget.getBoundingClientRect();

            // Calculate with 1-decimal precision (0.1% accuracy = 10x better than integers)
            // For a 1200px image: 0.1% = 1.2px granularity (sufficient for visual cropping)
            var rawX = ((e.clientX - rect.left) / rect.width) * 100;
            var rawY = ((e.clientY - rect.top) / rect.height) * 100;
            var x = Math.round(rawX * 10) / 10;  // Round to 1 decimal place
            var y = Math.round(rawY * 10) / 10;
            var self = this;

            console.log('[Enhanced Image] Focus point calculated:', { x: x, y: y });
            console.log('[Enhanced Image] Image dimensions:', { width: rect.width, height: rect.height });

            this.setState({
              focusPoint: {
                x: Math.max(0, Math.min(100, x)),
                y: Math.max(0, Math.min(100, y))
              },
              // Store image rect relative to container for correct indicator positioning
              // This allows us to position the indicator relative to the image, not the container
              imageRect: {
                offsetLeft: rect.left - containerRect.left,  // Image position within container
                offsetTop: rect.top - containerRect.top,
                width: rect.width,
                height: rect.height
              }
            }, function() {
              // emitChange() MUST be called in setState callback to ensure
              // DecapCMS receives updates after state is committed (immutable data pattern)
              // See: https://decapcms.org/docs/custom-widgets/
              self.emitChange();
            });
          },

          handleRemove: function() {
            this.setState({
              src: null,
              alt: '',
              focusPoint: { x: 50, y: 50 },
              crops: {}
            });
            this.props.onChange(null);
          },

          emitChange: function() {
            var src = this.state.src;

            console.log('[Enhanced Image] emitChange called');
            console.log('[Enhanced Image] src:', src);

            if (!src) {
              console.log('[Enhanced Image] No src, calling onChange(null)');
              this.props.onChange(null);
              return;
            }

            // ‚úÖ Phase 2.1: Extract public_id from full URL if needed (backwards compatibility)
            var publicId = window.CLOUDINARY_CONFIG.extractPublicId(src);
            if (publicId !== src) {
              console.log('[Enhanced Image] Extracted public_id from URL:', publicId);
            } else {
              console.log('[Enhanced Image] src is already public_id:', publicId);
            }

            // Build complete image data object with public_id (not full URL)
            var imageData = {
              src: publicId,  // ‚úÖ Store public_id, not full URL
              alt: this.state.alt || '',
              focusPoint: {
                x: this.state.focusPoint.x,
                y: this.state.focusPoint.y
              }
            };

            console.log('[Enhanced Image] Calling onChange with image data:', imageData);
            this.props.onChange(imageData);
          },

          handleDropzoneClick: function() {
            var self = this;
            console.log('='.repeat(60));
            console.log('[Enhanced Image] Opening Cloudinary Upload Widget');
            console.log('[Enhanced Image] Current state:', this.state);
            console.log('='.repeat(60));

            // Check if Cloudinary widget is available
            if (typeof window.cloudinary === 'undefined') {
              console.error('[Enhanced Image] Cloudinary widget not loaded!');
              self.setState({ error: 'Cloudinary widget nen√≠ k dispozici' });
              return;
            }

            // Open Cloudinary Upload Widget directly
            try {
              window.cloudinary.openUploadWidget({
                cloudName: window.CLOUDINARY_CONFIG.cloudName,
                uploadPreset: window.CLOUDINARY_CONFIG.uploadPreset,
                folder: window.CLOUDINARY_CONFIG.folder,
                sources: ['local', 'url', 'camera'],
                multiple: false,
                maxFiles: 1,
                clientAllowedFormats: ['jpg', 'jpeg', 'png', 'webp'],
                maxFileSize: 5000000, // 5MB
                resourceType: 'image',
                defaultSource: 'local',
                styles: {
                  palette: {
                    window: '#FFFFFF',
                    windowBorder: '#3b5f78',
                    tabIcon: '#3b5f78',
                    menuIcons: '#3b5f78',
                    textDark: '#000000',
                    textLight: '#FFFFFF',
                    link: '#44c2c4',
                    action: '#44c2c4',
                    inactiveTabIcon: '#888888',
                    error: '#F44336',
                    inProgress: '#44c2c4',
                    complete: '#4CAF50',
                    sourceBg: '#F5F5F5'
                  }
                }
              }, function(error, result) {
                console.log('[Enhanced Image] Cloudinary callback called');
                console.log('[Enhanced Image] Error:', error);
                console.log('[Enhanced Image] Result:', result);

                if (error) {
                  console.error('[Enhanced Image] Cloudinary error:', error);
                  self.setState({ error: 'Chyba p≈ôi nahr√°v√°n√≠: ' + error.message });
                  return;
                }

                // Handle successful upload
                if (result && result.event === 'success') {
                  console.log('[Enhanced Image] Upload successful!');
                  console.log('[Enhanced Image] Image info:', result.info);

                  // Extract public_id (e.g., "dgkralupy/image-name.jpg")
                  var publicId = result.info.public_id;
                  var secureUrl = result.info.secure_url;

                  console.log('[Enhanced Image] Public ID:', publicId);
                  console.log('[Enhanced Image] Secure URL (for preview):', secureUrl);

                  // Store public_id in src, use secure_url for preview
                  self.setState({
                    src: publicId,           // Store just the public_id
                    previewUrl: secureUrl,   // Use full URL for preview display
                    error: null
                  }, function() {
                    console.log('[Enhanced Image] State updated with public_id:', publicId);
                    self.emitChange();
                  });
                }
              });

              console.log('[Enhanced Image] Cloudinary widget opened successfully');
            } catch (error) {
              console.error('[Enhanced Image] Error opening Cloudinary widget:', error);
              self.setState({ error: 'Chyba p≈ôi otev≈ôen√≠ Cloudinary: ' + error.message });
            }
          },

          render: function() {
            var self = this;
            var src = this.state.src;
            var alt = this.state.alt;
            var focusPoint = this.state.focusPoint;
            var error = this.state.error;
            var isDragging = this.state.isDragging;
            var previewUrl = this.state.previewUrl;
            var imageRect = this.state.imageRect;

            // Build display URL: prefer previewUrl, but if not set and src exists,
            // build Cloudinary URL from public_id to avoid relative path 404 errors
            var displaySrc = previewUrl;
            if (!displaySrc && src) {
              // If src is a public_id (not a full URL), build Cloudinary URL
              if (!src.startsWith('http')) {
                displaySrc = window.CLOUDINARY_CONFIG.buildUrl(src);
              } else {
                displaySrc = src;
              }
            }

            console.log('[Enhanced Image] Rendering with state:', {
              src: src,
              alt: alt,
              focusPoint: focusPoint,
              previewUrl: previewUrl,
              displaySrc: displaySrc,
              error: error
            });

            var containerStyle = {
              border: '1px solid #ddd',
              borderRadius: '4px',
              padding: '16px',
              marginBottom: '16px'
            };

            var dropzoneStyle = {
              border: '2px dashed ' + (isDragging ? '#3b5f78' : '#ccc'),
              borderRadius: '8px',
              padding: '40px',
              textAlign: 'center',
              cursor: 'pointer',
              backgroundColor: isDragging ? '#f0f7ff' : 'transparent',
              transition: 'all 0.2s'
            };

            var errorStyle = {
              padding: '12px',
              backgroundColor: '#fee',
              border: '1px solid #fcc',
              borderRadius: '4px',
              color: '#c00',
              marginBottom: '12px'
            };

            return h('div', { className: 'enhanced-image-widget', style: containerStyle },
              error && h('div', { style: errorStyle }, error),
              
              !src && h('div', {
                style: dropzoneStyle,
                onClick: this.handleDropzoneClick
              },
                h('p', {}, 'üìÅ Kliknƒõte nebo p≈ôet√°hnƒõte obr√°zek'),
                h('p', { style: { fontSize: '12px', color: '#666', marginTop: '4px' } }, 
                  'JPG, PNG, WebP ‚Ä¢ Max 5 MB'),
                h('input', {
                  ref: function(ref) { self.fileInputRef = ref; },
                  type: 'file',
                  accept: 'image/jpeg,image/png,image/webp',
                  style: { display: 'none' },
                  onChange: this.handleFileSelect
                })
              ),
              
              src && h('div', { style: { marginTop: '16px' } },
                h('div', {
                  style: {
                    position: 'relative',
                    cursor: 'crosshair',
                    marginBottom: '16px'
                  },
                  onClick: this.handleFocusPointChange
                },
                  h('img', {
                    src: displaySrc,
                    alt: alt,
                    style: {
                      maxWidth: '100%',
                      display: 'block',
                      borderRadius: '4px'
                    },
                    onError: function(e) {
                      console.error('[Enhanced Image] Failed to load image:', displaySrc);
                      e.target.style.display = 'none';
                      // Optionally show error message
                    },
                    onLoad: function() {
                      console.log('[Enhanced Image] Image loaded successfully:', displaySrc);
                    }
                  }),
                  // Focus point indicator
                  // Calculate position in pixels relative to the actual image, not the container
                  h('div', {
                    style: {
                      position: 'absolute',
                      width: '20px',
                      height: '20px',
                      marginLeft: '-10px',
                      marginTop: '-10px',
                      borderRadius: '50%',
                      border: '3px solid #ff6b6b',
                      backgroundColor: 'rgba(255, 107, 107, 0.3)',
                      pointerEvents: 'none',
                      // Use pixel positioning based on image dimensions if available,
                      // otherwise fall back to percentage (for initial render before first click)
                      left: imageRect
                        ? (imageRect.offsetLeft + (focusPoint.x / 100) * imageRect.width) + 'px'
                        : focusPoint.x + '%',
                      top: imageRect
                        ? (imageRect.offsetTop + (focusPoint.y / 100) * imageRect.height) + 'px'
                        : focusPoint.y + '%'
                    }
                  })
                ),
                
                h('div', { style: { marginBottom: '12px' } },
                  h('label', {
                    style: {
                      display: 'block',
                      marginBottom: '4px',
                      fontWeight: 500,
                      fontSize: '14px'
                    }
                  }, 'Alternativn√≠ text (povinn√Ω)'),
                  h('input', {
                    type: 'text',
                    value: alt,
                    maxLength: MAX_ALT_LENGTH,
                    placeholder: 'Popis obr√°zku pro nevidom√© u≈æivatele',
                    style: {
                      width: '100%',
                      padding: '8px',
                      border: '1px solid #ddd',
                      borderRadius: '4px',
                      fontSize: '14px'
                    },
                    onChange: this.handleAltChange
                  }),
                  h('span', {
                    style: {
                      fontSize: '12px',
                      color: '#666',
                      marginTop: '4px',
                      display: 'block'
                    }
                  }, alt.length + '/' + MAX_ALT_LENGTH + ' znak≈Ø')
                ),
                
                h('div', {
                  style: {
                    padding: '8px',
                    backgroundColor: '#f5f5f5',
                    borderRadius: '4px',
                    fontSize: '13px',
                    marginBottom: '12px'
                  }
                },
                  h('strong', {}, 'Ohnisko: '),
                  focusPoint.x + '%, ' + focusPoint.y + '% ‚Ä¢ Kliknƒõte na obr√°zek pro zmƒõnu'
                ),
                
                h('button', {
                  type: 'button',
                  style: {
                    padding: '8px 16px',
                    backgroundColor: '#f44',
                    color: 'white',
                    border: 'none',
                    borderRadius: '4px',
                    cursor: 'pointer'
                  },
                  onClick: this.handleRemove
                }, 'üóëÔ∏è Odstranit obr√°zek')
              )
            );
          }
        });
        console.log('‚úÖ Enhanced Image control component defined');

        var EnhancedImagePreview = createClass({
          render: function() {
            var value = this.props.value || {};

            if (!value.src) {
              return h('div', {}, '≈Ω√°dn√Ω obr√°zek');
            }

            // Build Cloudinary URL from public_id to avoid relative path 404 errors
            var displaySrc = value.src;
            if (displaySrc && !displaySrc.startsWith('http')) {
              // It's a public_id, build Cloudinary URL
              displaySrc = window.CLOUDINARY_CONFIG.buildUrl(displaySrc);
            }

            return h('div', {},
              h('img', {
                src: displaySrc,
                alt: value.alt,
                style: {
                  maxWidth: '300px',
                  display: 'block',
                  marginBottom: '8px'
                }
              }),
              value.alt && h('p', {}, value.alt)
            );
          }
        });
        console.log('‚úÖ Enhanced Image preview component defined');

      // ==========================================
      // REGISTER WIDGETS
      // ==========================================
      console.log('');
      console.log('üìã Starting widget registration...');
      console.log('- CMS.registerWidget type:', typeof CMS.registerWidget);

      try {
        console.log('Registering author widget...');
        console.log('- Control:', typeof AuthorControl);
        console.log('- Preview:', typeof AuthorPreview);
        CMS.registerWidget('author', AuthorControl, AuthorPreview);
        console.log('‚úÖ Author widget registered successfully');

        console.log('Registering enhanced-image widget...');
        console.log('- Control:', typeof EnhancedImageControl);
        console.log('- Preview:', typeof EnhancedImagePreview);
        CMS.registerWidget('enhanced-image', EnhancedImageControl, EnhancedImagePreview);
        console.log('‚úÖ Enhanced-image widget registered successfully');

        console.log('');
        console.log('='.repeat(60));
        console.log('üéâ ALL CUSTOM WIDGETS REGISTERED SUCCESSFULLY');
        console.log('='.repeat(60));
      } catch (error) {
        console.error('');
        console.error('='.repeat(60));
        console.error('‚ùå WIDGET REGISTRATION FAILED');
        console.error('='.repeat(60));
        console.error('Error:', error);
        console.error('Error message:', error.message);
        console.error('Error stack:', error.stack);
        
        // Display error to user
        var errorDiv = document.createElement('div');
        errorDiv.style.cssText = '\
          position: fixed;\
          top: 20px;\
          left: 50%;\
          transform: translateX(-50%);\
          background: #fee;\
          border: 2px solid #c00;\
          color: #c00;\
          padding: 16px 24px;\
          border-radius: 8px;\
          z-index: 10000;\
          font-family: sans-serif;\
          max-width: 500px;\
          text-align: center;\
        ';
        errorDiv.textContent = 'Chyba p≈ôi registraci widget≈Ø: ' + error.message;
        document.body.appendChild(errorDiv);
      }

      // ==========================================
      // VERIFY REGISTRATION
      // ==========================================
      console.log('');
      console.log('üîç Verifying widget registration...');
      if (window.CMS && window.CMS.getWidget) {
        try {
          var authorWidget = CMS.getWidget('author');
          var imageWidget = CMS.getWidget('enhanced-image');
          console.log('- author widget:', authorWidget ? '‚úÖ Found' : '‚ùå Not found');
          console.log('- enhanced-image widget:', imageWidget ? '‚úÖ Found' : '‚ùå Not found');
        } catch (e) {
          console.log('‚ö†Ô∏è Could not verify widgets using CMS.getWidget():', e.message);
        }
      } else {
        console.log('‚ö†Ô∏è CMS.getWidget() not available');
      }

      // ==========================================
      // HIDE LOADING OVERLAY WHEN CMS READY
      // ==========================================
      CMS.registerEventListener({
        name: 'postPublish',
        handler: function() {
          var loadingOverlay = document.getElementById('loading-overlay');
          if (loadingOverlay) {
            loadingOverlay.classList.add('hidden');
          }
        }
      });

      // Hide loading overlay after a short delay to ensure CMS has mounted
      setTimeout(function() {
        var loadingOverlay = document.getElementById('loading-overlay');
        if (loadingOverlay) {
          loadingOverlay.classList.add('hidden');
        }
      }, 1000);

    })();
  </script>
</body>
</html>