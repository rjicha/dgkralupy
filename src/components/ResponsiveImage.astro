---
/**
 * ResponsiveImage Component
 *
 * Displays images with support for both legacy (string) and enhanced (object) formats.
 * Provides graceful fallback when image optimization is not available.
 *
 * @component
 * @example
 * <!-- Legacy format (string) -->
 * <ResponsiveImage image="/images/photo.jpg" variant="hero" />
 *
 * @example
 * <!-- Enhanced format (object) -->
 * <ResponsiveImage
 *   image={{ src: "/images/photo.jpg", alt: "Description", focusPoint: { x: 60, y: 40 } }}
 *   variant="card"
 *   loading="lazy"
 * />
 */

import { normalizeImageData } from '../lib/utils/imageProcessing';
import { getCloudinaryUrl, extractPublicId } from '../lib/utils/cloudinary';
import type { ImageData } from '../types/image';
import type { ImageVariant } from '../lib/utils/imageVariants';

interface Props {
  /** Image data (supports both string path and object format) */
  image: ImageData;
  /** Variant to use (hero, card, thumbnail, detail) */
  variant: ImageVariant;
  /** Loading strategy (lazy or eager) */
  loading?: 'lazy' | 'eager';
  /** Additional CSS classes */
  class?: string;
  /** Additional inline styles */
  style?: string;
  /** Alt text override (fallback if not in image data) */
  alt?: string;
}

const {
  image,
  variant,
  loading = 'lazy',
  class: className = '',
  style = '',
  alt: altOverride
} = Astro.props;

// Normalize image data (handles both string and object formats)
const imageData = normalizeImageData(image);

// Use alt from props, then from image data, then empty string
const altText = altOverride || imageData.alt || '';

// Check if image is from Cloudinary
const isCloudinaryImage = imageData.src.includes('cloudinary.com') ||
                          imageData.src.includes('res.cloudinary.com');

let imageSrc: string;

if (isCloudinaryImage) {
  // Use Cloudinary with transformations
  const publicId = extractPublicId(imageData.src);
  imageSrc = getCloudinaryUrl(publicId, variant, imageData.focusPoint);
} else {
  // Legacy: local images (fallback for existing content)
  imageSrc = imageData.src.startsWith('http')
    ? imageData.src
    : `${import.meta.env.BASE_URL}/${imageData.src.replace(/^\//, '')}`;
}

// Calculate object-position from focus point (fallback for local images)
const objectPosition = imageData.focusPoint
  ? `${imageData.focusPoint.x}% ${imageData.focusPoint.y}%`
  : 'center';

/**
 * Implementation notes:
 * - Cloudinary images: Transformations applied via URL (focus point, resize, format optimization)
 * - Local images: Fallback using object-position CSS for focus point
 * - Automatic format optimization for Cloudinary (AVIF, WebP, JPG based on browser)
 * - Backward compatible with existing local images
 */
---

<img
  src={imageSrc}
  alt={altText}
  loading={loading}
  decoding="async"
  class={className}
  style={isCloudinaryImage ? style : `object-position: ${objectPosition}; ${style}`}
  data-variant={variant}
  data-cloudinary={isCloudinaryImage}
  data-focus-point={imageData.focusPoint ? `${imageData.focusPoint.x},${imageData.focusPoint.y}` : undefined}
/>
